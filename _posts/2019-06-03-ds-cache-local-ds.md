---
layout: post
title: 03 本地缓存、分布式缓存
categories: [Cache]
description: Cache 本地缓存、分布式缓存
keywords: Redis, Cache
topmost: false
---

#### 缓存

磁盘=>内存 提高性能，解决高并发中磁盘IO容易成为性能瓶颈问题

- 本地缓存：    缓存属于同进程

- 分布式缓存：  缓存属于多进程

#### 本地缓存

- 1.访问速度快，但无法进行大数据存储
- 2.集群的数据更新问题：无法被其他进程访问  
  如放入数据库，需处理一致性问题，复杂度高容易出错

- 3.数据随应用进程的重启而丢失，本地进程重启，缓存丢失，要注意持久化 

适用性：适合只读数据

实现： 缓存结构一般是 k-v  
Java HashMap ConcurrentHashMap(安全)，Google **Guava** **Cache**实现(安全)

##### 1.Java集合类 **无法回收**不常用的缓存

HashMap 、 LinkedHashMap 、 TreeMap 、 LinkedTreeMap 、 ConcurrentHashMap

##### 2.**Guava Cach**e: 本地缓存实现

基于LRU算法实现，并提供了多种缓存过期策略，过期时间、容量等. 简化了缓存的使用 

##### 3.**Caffeine** 近乎最佳命中率的高性能的缓存库

https://github.com/ben-manes/caffeine/wiki/Benchmarks 性能测试

Java8 用它替换了 Guava Cache 

##### 4.Ehcache Java开源缓存框架

配置简单、结构清晰、功能强大，是一个非常轻量级的缓存实现



#### 分布式缓存

- 1.支持**大数据量**存储，不受应用**进程重启**影响

- 2.数据集中存储，保证数据**一致性**

- 3.数据**读写分离**，高性能，高可用 （副本、冗余）

- 4.数据跨网络传输，性能低于本地缓存

##### 实现方案

###### 1.MemCached 

以独立进程方式存在，数据集中存储，数据不随应用程序的重启而丢失，不支持数据结构的特性 

###### 2.Redis 单线程

- 1）不存在并发数据读写的线程安全问题

- 2）以及更重要的是保证的数据读写操作的顺序性 

Redis 支持

```
主从同步（读写分离）、集群分片拓展、数据持久化等特性 这也是 MemCached 不支持的 
在高并发场景并且数据能够容忍极端情况下的少量丢失、或者说丢失后可以恢复，如通过日志或者重新计算等
Redis 也可以作为数据库来使用，提高高并发场景中的访问性能
```

###### 3.Memcached 

一个高性能的、分布式的基于内存的key-value对象存储系统，用来存储小块的任意数据（字符串、对象）

###### 6.Redis 

高性能的基于内存中数据结构存储，用作数据库，缓存和消息代理

Redis具有内置的复制，Lua脚本，LRU逐出，事务和不同级别的磁盘持久性，并通过Redis Sentinel和Redis Cluster自动分区提供高可用性
  

#### Spring Cache 缓存管理的抽象解决方案

======= 消除了样板方法的使用，屏蔽了缓存的使用细节

 还具备相当的灵活性，可以使用 SpEL 来定义缓存的 key 和各种 condition，提供了灵活的开箱即用的解决方案










## 参考：

