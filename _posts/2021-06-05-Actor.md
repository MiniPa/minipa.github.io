---
layout: post
title: Actor 并发编程模型
comments: true,
categories: [Actor, 高并发]
description: Reactor 响应式编程模型
keywords: reactor, concurrency
topmost: false
---

## Java核心技术 思维导图： 节点 (Concurrency 并发 -> Actor)
<iframe id="embed_dom" name="embed_dom" frameborder="0" style="display:block;width:770px; height:435px;" src="https://www.processon.com/embed/623b22e5e401fd070bbe3acd"></iframe>


## 并发编程模型

### 7个并发编程模型
```
1.线程与锁：线程与锁模型有很多众所周知的不足，但仍是其他模型的技术基础，也是很多并发软件开发的首选

2.函数式编程：函数式编程日渐重要的原因之一，是其对并发编程和并行编程提供了良好的支持。函数式编程消除了可变状态，所以从根本上是线程安全的，而且易于并行执行。

3.Clojure之道——分离标识与状态：编程语言Clojure是一种指令式编程和函数式编程的混搭方案，在两种编程方式上取得了微妙的平衡来发挥两者的优势。

4.actor：actor模型是一种适用性很广的并发编程模型，适用于共享内存模型和分布式内存模型，也适合解决地理分布型问题，能提供强大的容错性。

5.通信顺序进程（Communicating Sequential Processes，CSP）：
	表面上看，CSP模型与actor模型很相似，两者都基于消息传递。
	不过CSP模型侧重于传递信息的通道，而actor模型侧重于通道两端的实体，使用CSP模型的代码会带有明显不同的风格。

6.数据级并行：每个笔记本电脑里都藏着一台超级计算机——GPU。
	GPU利用了数据级并行，不仅可以快速进行图像处理，也可以用于更广阔的领域。
	如果要进行有限元分析、流体力学计算或其他的大量数字计算，GPU的性能将是不二选择。

7.Lambda架构：大数据时代的到来离不开并行——现在我们只需要增加计算资源，就能具有处理TB级数据的能力。
  Lambda架构综合了MapReduce和流式处理的特点，是一种可以处理多种大数据问题的架构。
```

### 并发与并行
#### 1.定义
- 并发是同一时间应对（dealing with）多件事情的能力
- 并行是同一时间动手做（doing）多件事情的能力

#### 2.案例
```aidl
我妻子是一位教师。与众多教师一样，她极其善于处理多个任务。她虽然每次只能做一件事，但可以并发地处理多个任务。
	比如，在听一位学生朗读的时候，她可以暂停学生的朗读，以维持课堂秩序，或者回答学生的问题。这是并发，但并不并行（因为仅有她一个人，某一时刻只能进行一件事）。

但如果还有一位助教，则她们中一位可以聆听朗读，而同时另一位可以回答问题。这种方式既是并发，也是并行。

假设班级设计了自己的贺卡并要批量制作。一种方法是让每位学生制作五枚贺卡。这种方法是并行，而（从整体看）不是并发，因为这个过程整体来说只有一个任务。
```

#### 3.并行架构
- 1.位级（bit-level）并行
```aidl
为什么32位计算机比8位计算机运行速度更快？
对于两个32位数的加法，8位计算 机必须进行多次8位计算，而32位计算机可以一步完成，即并行地处理32位数的4字节。 
由位升级带来的性能改 善是存在瓶颈的，这也正是短期内我们无法步入128位时代的原因
```
- 2.指令级（instruction-level）并行
```aidl
现代CPU的并行度很高，其中使用的技术包括流水线、乱序执行和猜测执行等
处理器的设计者们为单核提升速度变得越 来越困难
无论是表面上还是实质上，指令都不再串行 执行了
```
- 3.数据级（data）并行 数据级并行
```aidl
（也称为“单指令多数据”，SIMD）架构，可以并行地在大量数据上施加同一操 作图像处理就是一种适合进行数据级并行的场景
增加每一个像 素的亮度。现代GPU（图形处理器）也因图像处理的特点而演化成了极其强大的数据并行处理器
```
- 4.任务级（task-level）并行
```aidl
多处理器
从程序员的角度来看，多处理器架构最明 显的分类特征是其内存模型（共享内存模型或分布式内存模型）
共享内存的多处理器系统，每个处理器都能访问整个内存，处理器之间的通信主要通过 内存进行
```

#### 4.并发
##### 并发背景
这是一个并发世界，并发是系统及时响应的关键；这是一个分布式的世界，具有容错性；复杂的世界，简单的软件来执行。

##### 并发处理策略
- 共享数据：lock，强一致、弱隔离
- 消息传递：不会产生数据竞争，强隔离、弱一致，有良好的并发性


## Actor 并发编程模型

![actor](/images/types/cur/actor.png)

### 1.处理步骤
- 1）创建actor、发送消息和接收消息
- 2）使用actor模型的程序具有容错性的关键，失败检测和“任其崩溃”的哲学
- 3）通过actor模型编写分布式程序，将计算扩展到多台计算机，并能从一台或多台计算机的崩溃中恢复过来

### 2.特性
```aidl
- 有序、非阻塞：  
消息通信，异步发送消息，不会阻塞，关注消息发送顺序即可；事件驱动，一个Actor一次处理一个事件，消除了共享状态
- 强隔离：两端异步，消息通信
- 位置透明：Actor在本地还是远程一样，消息通信
- 轻量性：400byte的Actor
- 解耦：任务调度与业务处理解耦，实现更高级抽象
```

### 3.缺点
```aidl
注意数据爆炸
必须共享数据，很难避免锁
不适合消息严格有序场景（按发送消息排序，时间问题）
```

### 4.结构设计
```aidl
state 状态： actor 管理自己的状态，避免并发 锁/原子性 问题
behavior 行为： 计算逻辑，改变 actor 状态
mailbox 邮箱： 消息队列，按照消息发送顺序入队
```
```aidl
task: 任务
tag - 区分任务消息标记
target - 消息到达的地址
communication - 任务处理可获得的信息
```

### 5.避免并发编程的公理
- 消息驱动：actor外部无法访问内部
- 非阻塞：actor可以阻塞自己，不能阻塞执行线程
- 行为：改变自己/推出新 actor 

### 6.调度方式
- 基于线程： 每个 actor 一个线程，不建议
- 基于事件： 有事件才会分配线程



