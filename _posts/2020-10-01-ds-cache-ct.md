---
layout: post
title: 05 缓存穿透、缓存雪崩
categories: [Cache]
description: 缓存穿透、缓存雪崩 
keywords: Redis, Cache
topmost: false
---

#### 缓存穿透

用户想要查询一个数据

```
1.发现redis内存数据库没有，也就是缓存没有命中，
2.于是向持久层数据库查询。发现也没有，于是本次查询失败。
==> 当用户很多的时候，缓存都没有命中，于是都去请求了持久层数据库。
这会给持久层数据库造成很大的压力，这时候就相当于出现了缓存穿透。
```

**缓存击穿**的区别，缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问

当这个**key在失效的瞬间**，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞

[Blog](https://baijiahao.baidu.com/s?id=1655304940308056733&wfr=spider&for=pc)
![ct1](/images/posts/distribute-system-cache/ct1.png)

![ct2](/images/posts/distribute-system-cache/ct2.png)

#### 缓存雪崩

缓存雪崩是指，缓存层出现了错误，不能正常工作了。
于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况

![xb](/images/posts/distribute-system-cache/xb.png)

【解决方案】

##### （1）**redis高可用**

这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群。

##### （2）**限流降级**

这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。  
比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。 

##### （3）**数据预热**

数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，  
这样部分可能大量访问的数据就会加载到缓存中。

在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。



[Blog](https://www.cnblogs.com/xichji/p/11286443.html)












## 参考：

